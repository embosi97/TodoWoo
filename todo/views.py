from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
# to generate the model to create a user object
from django.contrib.auth.models import User
from django.db import IntegrityError #checks to see if the user has already created an object that already exists in the DB
from django.contrib.auth import login, logout, authenticate
from .forms import TodoForm
from .models import Todo
from django.utils import timezone
from django.contrib.auth.decorators import login_required
# Views for this project

def home(request):
    return render(request,'todo/home.html')

def signupuser(request):
    if request.method == 'GET':
        #Passing in a User Creation Form that is generated by Django itself
        #No reason to reinvent the wheel
        return render(request, 'todo/signupuser.html',{'form':UserCreationForm()})
    else:
        #If the 2 passwords match, continue
        if request.POST['password1'] == request.POST['password2']:
            try:
                #Creates a new user with the inputted username and password
                user = User.objects.create_user(request.POST['username'], password=request.POST['password1'])
                #Saves the user into the DB
                user.save()
                #Logins in with the new user's credentials
                login(request, user)
                #Then finally redirects to the user's current todo's (shouldn't have any)
                return redirect('currenttodos')

            except IntegrityError :
                #If there is an integrity error (user already exists), redirect to the same page with an error
                return render(request, 'todo/signupuser.html',{'form':UserCreationForm(), 'error':'That username has already been taken! Please choose a new user name. Try Again '})


        else:
            #Informs the user that the passwords infact do not match
             return render(request, 'todo/signupuser.html',{'form':UserCreationForm(), 'error':'Passwords did not match'})

#This decorator essentially means that if there isn't a login, then logoutuser cannot happen. It will redirect to signupuser until user is logged into their account
@login_required
def logoutuser(request):
    if request.method =='POST':
        #Logs out
        logout(request)
        return redirect('home')

def loginuser(request):

     if request.method == 'GET':
        #Sends an Djano-generated Authentication Form
        return render(request, 'todo/loginuser.html',{'form':AuthenticationForm()})
     else:
         #If POST, returns a user object with the inputted information that is first authenticated
        user =  authenticate(request, username=request.POST['username'], password=request.POST['password'])
        #if the username did not match throw it doesnt exist error
        if user is None:
            #If login information is not found in the DB, refresh page with an error message
            return render(request, 'todo/loginuser.html',{'form':AuthenticationForm(),'error': 'Username and password did not match'})
        else:
            #If information is found in the DB, login the user and redirect to their current todos
            login(request, user)
            return redirect('currenttodos')

@login_required
def currenttodos(request):
    #Get all the todo objects (only if the datecompleted is null) from the logged-in user
    todos = Todo.objects.filter(user=request.user, datecompleted__isnull=True)
    return render(request,'todo/currenttodos.html',{'todos':todos})


@login_required
def viewtodo(request, todo_pk):
    #todo_pk is the id for the particular todo you want to view
    #user = request.user ensures another user can't look at another user's todos
    todo = get_object_or_404(Todo, pk = todo_pk, user = request.user )

    if request.method == 'GET':
        #HTML form we created in forms.oy
        form = TodoForm(instance=todo)
        return render(request,'todo/viewtodo.html',{'todo':todo, 'form':form})
    else:
        try:
            #Save the change to the Todo
            form = TodoForm(request.POST, instance=todo)
            form.save()
            return redirect('currenttodos')
        except ValueError:
            return render(request,'todo/viewtodo.html',{'todo':todo, 'form':form, 'error':"Bad info!"})




@login_required
def createtodo(request):
    if request.method == 'GET':
        return render(request, 'todo/createtodo.html',{'form':TodoForm()})
    else:
        try:
            #first get the information from the post request and connect with our form
            #pass in any information that is saved in POST
            form = TodoForm(request.POST)
            #create a new todo object but don't put it in the data base yet
            newTodo = form.save(commit=False)
            #the object will get the user, so we are specifying only the user
            newTodo.user = request.user
            #now put it back into the data base
            newTodo.save()
            #return back to the page
            return redirect('currenttodos')
        except ValueError:
            return  render(request, 'todo/createtodo.html',{'form':TodoForm(), 'error':'Bad Data passed in'})

@login_required
def completetodo(request, todo_pk):
    todo = get_object_or_404(Todo, pk=todo_pk, user=request.user) #only the user should be able to complete
    #only people that can post can complete a todo
    if request.method == 'POST':
        #Now that datecompleted is not null, it won't appear in currenttodos since we specified only those with null can be there
        todo.datecompleted = timezone.now()
        todo.save()
        return redirect('currenttodos')

@login_required
def deletetodo(request, todo_pk):
    todo = get_object_or_404(Todo, pk=todo_pk, user=request.user)
    if request.method == 'POST':
        #deletes the todo from the DB
        todo.delete()
        return redirect('currenttodos')

@login_required
def completedtodos(request):
    #All objects that have a datecompleted go here (completedtodos)
    todos = Todo.objects.filter(user=request.user, datecompleted__isnull=False).order_by('-datecompleted')
    return render(request,'todo/completedtodos.html',{'todos':todos})
